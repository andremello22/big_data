# -*- coding: utf-8 -*-
"""Colab Mags_Brasa_Burguer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11gWONY3RnTbaC1jHYZEJ3j_SEQzNtRhD

#  Projeto de Big Data para Empresa Mags Brasa Burguer
 ![images.jfif](data:image/jpeg;base64,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)

# Importando Bibliotecas
"""

import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import datetime

df= pd.read_excel("Mags brasa Burger.xlsx")

df.head(3)

df.columns

'''
Criação de 2 df para análises exploratorias
* 1- Analise de vendas, serie temporais e canais de vendas
* 2- Analisar os cancelamentos, os motivos e se é possivel contestar
'''
df_analise_vendas=df[['ID DO PEDIDO','Data','Dia da semana','Hora','TAXA DE ENTREGA','VALOR DOS ITENS','TOTAL DO PEDIDO','FORMAS DE PAGAMENTO','CANAL DE VENDA','MOTIVO DO CANCELAMENTO']].copy()
df_analise_cancelamentos=df[['DATA DO CANCELAMENTO', 'ORIGEM DO CANCELAMENTO','MOTIVO DO CANCELAMENTO', 'CANCELAMENTO É CONTESTÁVEL','MOTIVO DA IMPOSSIBILIDADE DE CONTESTAR', 'DATA LIMITE DE CONTESTAÇÃO']].copy()

df_analise_vendas['Hora'] = pd.to_timedelta(df_analise_vendas['Hora'])
df_analise_vendas['Horas'] = df_analise_vendas['Hora'].dt.total_seconds() // 3600

df_analise_vendas.head(3)

df_analise_vendas.dtypes

# value_counts para contar a quantidade de ocorrências de cada dia da semana.
quantidade_por_dia = df_analise_vendas['Dia da semana'].value_counts()

# groupby para calcular a soma do 'TOTAL DO PEDIDO' para cada dia da semana.
soma_total_por_dia = df_analise_vendas.groupby('Dia da semana')['TOTAL DO PEDIDO'].sum()

# DataFrame a partir dos resultados.
count_dia = pd.DataFrame({
    'Dia da semana': quantidade_por_dia.index,
    'Quantidade': quantidade_por_dia.values,
    'Soma Total do Pedido': soma_total_por_dia[quantidade_por_dia.index].values
})
print(count_dia)



"""# Gráfico de faturamento nos dias da Semana"""

from plotly.subplots import make_subplots
import plotly.graph_objects as go

# Criar os gráficos individualmente
fig_line = px.line(count_dia, x='Dia da semana', y='Soma Total do Pedido',text='Soma Total do Pedido',
                   )

fig_bar = px.bar(count_dia, x='Dia da semana', y='Quantidade',
                 color='Quantidade')

fig_line.update_traces(texttemplate='R$%{y}', mode='lines+markers+text', textposition='top center')

# Criar o subplot
fig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.1,
                    )

# Adicionar os gráficos ao subplot
fig.add_trace(fig_bar.data[0], row=2, col=1)
fig.add_trace(fig_line.data[0], row=1, col=1)

# Atualizar o layout do subplot
fig.update_layout(title='Dias com mais vendas e Soma Total do Pedido <br><sub> O Domingo é o dia com maior quantidade de vendas', height=800, width=1000)

fig_bar.update_yaxes(range=[0, 200])

# Atualizar os rótulos dos eixos
fig.update_xaxes(title_text='Dia da semana', row=2, col=1)

fig.show()

"""# Gráfico Quantidade de vendas x hora da semana"""

pivot_table = df_analise_vendas.pivot_table(index='Dia da semana', columns='Horas', values='ID DO PEDIDO', aggfunc='count')
colorscale1 = [[0, "rgb(166,206,227)"],
               [0.25, "rgb(31,120,180)"],
               [0.45, "rgb(178,223,138)"],
               [0.65, "rgb(51,160,44)"],
               [0.85, "rgb(251,154,153)"],
               [1, "rgb(227,26,28)"]]

# Criar o heatmap
fig = go.Figure(data=go.Heatmap(
                   z=pivot_table.values,
                   x=pivot_table.columns,
                   y=pivot_table.index,
                   colorscale=colorscale1))
fig.update_xaxes(range=[0, 24])

# título e rótulos
fig.update_layout(title='Comportamento de Compra por Dia da Semana e Horas<br><sub>As vendas são impulsionadas a partir de 19:00h',
                  xaxis_title='Horas e Minutos',
                  yaxis_title='Dia da Semana')

fig.show()

print(pivot_table)

out = df_analise_vendas[df_analise_vendas['Horas'] == 4]
display(out)

"""- A cima podemos ver que no horário  das 4:49, foi um pedido que foi cancelado pois foi um pedido acidental"""

df_analise_vendas['nova_data'] = pd.to_datetime(df_analise_vendas['Data'], format='%d/%m/%y').dt.strftime('%Y-%m-%d')

"""# Quantidade de Pedidos por mês

"""

import pandas as pd
import plotly.express as px

# Convertendo 'nova_data' para formato de data
df_analise_vendas['nova_data'] = pd.to_datetime(df_analise_vendas['nova_data'])

# Agregar por mês e contar os pedidos
df_pedidos_por_mes = df_analise_vendas.groupby(df_analise_vendas['nova_data'].dt.to_period("M"))['ID DO PEDIDO'].count().reset_index()

# Convertendo a coluna 'nova_data' de Period para string no formato 'YYYY-MM'
df_pedidos_por_mes['nova_data'] = df_pedidos_por_mes['nova_data'].dt.to_timestamp().dt.strftime('%Y-%m')

# Criar o gráfico de linhas
fig = px.line(df_pedidos_por_mes, x='nova_data', y='ID DO PEDIDO', title='Número de Pedidos por Mês')

fig.update_xaxes(
    rangeslider_visible=True,
    rangeselector=dict(
        buttons=list([
            dict(count=1, label="1m", step="month", stepmode="backward"),
            dict(count=6, label="2m", step="month", stepmode="backward"),
            dict(count=6, label="3m", step="month", stepmode="backward"),
            dict(step="all")
        ])
    )
)

# Definir o intervalo inicial para cobrir os meses de junho a dezembro de 2023
fig.update_xaxes(range=['2023-06', '2023-12'])
fig.update_yaxes(range=[0, 300])

# Adicionar rótulos com o número de pedidos
for i, row in df_pedidos_por_mes.iterrows():
    fig.add_trace(
        go.Scatter(
            x=[row['nova_data']],
            y=[row['ID DO PEDIDO']],
            mode='text',
            text=str(row['ID DO PEDIDO']),
            textposition='top center'
        )
    )


fig.show()

grupo = df_analise_vendas.groupby(['CANAL DE VENDA', 'FORMAS DE PAGAMENTO']).size().reset_index(name='Contagem')

# Criando o gráfico de barras agrupado
fig = px.bar(grupo, x='FORMAS DE PAGAMENTO', y='Contagem', color='CANAL DE VENDA',
             barmode='group', labels={'CANAL DE VENDA': 'Canal de Venda'},
             title='Formas de Pagamento por Canal de Venda<br><sub>Podemos notar que o cardápio digital o pagamento por dinheiro possui menos descontos<br>Por outro lado o iFood proporciona mais opções de pagamento')

# Mostrando o gráfico
fig.show()

"""- No gráfico a cima podemos tirar a conclusão que o canal de de vendas pelo cardápio Digital é melhor financeiramente para a empresa pois os pagamentos são feitos em maioria por dinheiro e pix, não havendo taxa extra das maquinas de cartão.
- Por outro ladoo Ifood fornece mais opções de pagamentos sendo um otima oportunidade para atrair clientes novos.
"""

from wordcloud import WordCloud
import matplotlib.pyplot as plt


# Filtrando os valores NaN da coluna 'MOTIVO DO CANCELAMENTO'
motivos_cancelamento = df_analise_cancelamentos['MOTIVO DO CANCELAMENTO'].dropna()

# Junte todos os textos em uma única string
texto = ' '.join(motivos_cancelamento)

# Crie a nuvem de palavras sem especificar uma fonte
nuvem_palavras = WordCloud(width=800, height=400, background_color='white',
                           contour_color='steelblue', colormap='viridis',
                           max_words=200).generate(texto)

# Plote a nuvem de palavras
plt.figure(figsize=(10, 5))
plt.imshow(nuvem_palavras, interpolation='bilinear')
plt.axis('off')
plt.show()